form {
  /* Center the form on the page */
  margin: 0 auto;
  width: 400px;
  /* Form outline */
  padding: 1em;
  border: 1px solid #CCC;
  border-radius: 1em;
}

ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

form li + li {
  margin-top: 1em;
}

label {
  /* Uniform size & alignment */
  display: inline-block;
  width: 90px;
  text-align: right;
}

input, 
textarea {
  /* To make sure that all text fields have the same font settings
     By default, textareas have a monospace font */
  font: 1em sans-serif;

  /* Uniform text field size */
  width: 300px;
  box-sizing: border-box;

  /* Match form field borders */
  border: 1px solid #999;
}

input:focus, 
textarea:focus {
  /* Additional highlight for focused elements */
  border-color: #000;
}

textarea {
  /* Align multiline text fields with their labels */
  vertical-align: top;

  /* Provide space to type some text */
  height: 5em;
}

.button {
  /* Align buttons with the text fields */
  padding-left: 90px; /* same size as the label elements */
}

button {

  /*<!DOCTYPE html>
  <!--
   *  Copyright (c) 2015 The WebRTC project authors. All Rights Reserved.
   *
   *  Use of this source code is governed by a BSD-style license
   *  that can be found in the LICENSE file in the root of the source
   *  tree.
  -->
  <html>
  <head>
  
      <meta charset="utf-8">
      <meta name="description" content="WebRTC code samples">
      <meta name="viewport" content="width=device-width, user-scalable=yes, initial-scale=1, maximum-scale=1">
      <meta itemprop="description" content="Client-side WebRTC code samples">
      <meta itemprop="image" content="../../../images/webrtc-icon-192x192.png">
      <meta itemprop="name" content="WebRTC code samples">
      <meta name="mobile-web-app-capable" content="yes">
      <meta id="theme-color" name="theme-color" content="#ffffff">
  
      <base target="_blank">
  
      <title>getUserMedia to canvas</title>
  
      <link rel="icon" sizes="192x192" href="../../../images/webrtc-icon-192x192.png">
      <link href="//fonts.googleapis.com/css?family=Roboto:300,400,500,700" rel="stylesheet" type="text/css">
      <link rel="stylesheet" href="../../../css/main.css">
  
  </head>
  
  <body>
  
  <div id="container">
  
      <h1><a href="//webrtc.github.io/samples/" title="WebRTC samples homepage">WebRTC samples</a> <span>getUserMedia â‡’ canvas</span>
      </h1>
  
      <video playsinline autoplay></video>
      <button>Take snapshot</button>
      <canvas></canvas>
  
      <p>Draw a frame from the video onto the canvas element using the <code>drawImage()</code> method.</p>
  
      <p>The variables <code>canvas</code>, <code>video</code> and <code>stream</code> are in global scope, so you can
          inspect them from the console.</p>
  
      <a href="https://github.com/webrtc/samples/tree/gh-pages/src/content/getusermedia/canvas"
         title="View source for this page on GitHub" id="viewSource">View source on GitHub</a>
  
  </div>
  
  <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
  <script src="js/main.js" async></script>
  <script src="../../../js/lib/ga.js"></script>
  
  </body>
  </html>

  /*
 *  Copyright (c) 2015 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 

'use strict';

// Put variables in global scope to make them available to the browser console.
const video = document.querySelector('video');
const canvas = window.canvas = document.querySelector('canvas');
canvas.width = 480;
canvas.height = 360;

const button = document.querySelector('button');
button.onclick = function() {
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;
  canvas.getContext('2d').drawImage(video, 0, 0, canvas.width, canvas.height);
};

const constraints = {
  audio: false,
  video: true
};

function handleSuccess(stream) {
  window.stream = stream; // make stream available to browser console
  video.srcObject = stream;
}

function handleError(error) {
  console.log('navigator.MediaDevices.getUserMedia error: ', error.message, error.name);
}

navigator.mediaDevices.getUserMedia(constraints).then(handleSuccess).catch(handleError);
 This extra margin represent roughly the same space as the space
     between the labels and their text fields */
  margin-left: .5em;
}


/*
 *  Copyright (c) 2015 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 

 'use strict';

 const dimensions = document.querySelector('#dimensions');
 const video = document.querySelector('video');
 let stream;
 
 const vgaButton = document.querySelector('#vga');
 const qvgaButton = document.querySelector('#qvga');
 const hdButton = document.querySelector('#hd');
 const fullHdButton = document.querySelector('#full-hd');
 const cinemaFourKButton = document.querySelector('#cinemaFourK');
 const televisionFourKButton = document.querySelector('#televisionFourK');
 const eightKButton = document.querySelector('#eightK');
 
 const videoblock = document.querySelector('#videoblock');
 const messagebox = document.querySelector('#errormessage');
 
 const widthInput = document.querySelector('div#width input');
 const widthOutput = document.querySelector('div#width span');
 const aspectLock = document.querySelector('#aspectlock');
 const sizeLock = document.querySelector('#sizelock');
 
 let currentWidth = 0;
 let currentHeight = 0;
 
 vgaButton.onclick = () => {
   getMedia(vgaConstraints);
 };
 
 qvgaButton.onclick = () => {
   getMedia(qvgaConstraints);
 };
 
 hdButton.onclick = () => {
   getMedia(hdConstraints);
 };
 
 fullHdButton.onclick = () => {
   getMedia(fullHdConstraints);
 };
 
 televisionFourKButton.onclick = () => {
   getMedia(televisionFourKConstraints);
 };
 
 cinemaFourKButton.onclick = () => {
   getMedia(cinemaFourKConstraints);
 };
 
 eightKButton.onclick = () => {
   getMedia(eightKConstraints);
 };
 
 const qvgaConstraints = {
   video: {width: {exact: 320}, height: {exact: 240}}
 };
 
 const vgaConstraints = {
   video: {width: {exact: 640}, height: {exact: 480}}
 };
 
 const hdConstraints = {
   video: {width: {exact: 1280}, height: {exact: 720}}
 };
 
 const fullHdConstraints = {
   video: {width: {exact: 1920}, height: {exact: 1080}}
 };
 
 const televisionFourKConstraints = {
   video: {width: {exact: 3840}, height: {exact: 2160}}
 };
 
 const cinemaFourKConstraints = {
   video: {width: {exact: 4096}, height: {exact: 2160}}
 };
 
 const eightKConstraints = {
   video: {width: {exact: 7680}, height: {exact: 4320}}
 };
 
 function gotStream(mediaStream) {
   stream = window.stream = mediaStream; // stream available to console
   video.srcObject = mediaStream;
   messagebox.style.display = 'none';
   videoblock.style.display = 'block';
   const track = mediaStream.getVideoTracks()[0];
   const constraints = track.getConstraints();
   console.log('Result constraints: ' + JSON.stringify(constraints));
   if (constraints && constraints.width && constraints.width.exact) {
     widthInput.value = constraints.width.exact;
     widthOutput.textContent = constraints.width.exact;
   } else if (constraints && constraints.width && constraints.width.min) {
     widthInput.value = constraints.width.min;
     widthOutput.textContent = constraints.width.min;
   }
 }
 
 function errorMessage(who, what) {
   const message = who + ': ' + what;
   messagebox.innerText = message;
   messagebox.style.display = 'block';
   console.log(message);
 }
 
 function clearErrorMessage() {
   messagebox.style.display = 'none';
 }
 
 function displayVideoDimensions(whereSeen) {
   if (video.videoWidth) {
     dimensions.innerText = 'Actual video dimensions: ' + video.videoWidth +
       'x' + video.videoHeight + 'px.';
     if (currentWidth !== video.videoWidth ||
       currentHeight !== video.videoHeight) {
       console.log(whereSeen + ': ' + dimensions.innerText);
       currentWidth = video.videoWidth;
       currentHeight = video.videoHeight;
     }
   } else {
     dimensions.innerText = 'Video not ready';
   }
 }
 
 video.onloadedmetadata = () => {
   displayVideoDimensions('loadedmetadata');
 };
 
 video.onresize = () => {
   displayVideoDimensions('resize');
 };
 
 function constraintChange(e) {
   widthOutput.textContent = e.target.value;
   const track = window.stream.getVideoTracks()[0];
   let constraints;
   if (aspectLock.checked) {
     constraints = {
       width: {exact: e.target.value},
       aspectRatio: {
         exact: video.videoWidth / video.videoHeight
       }
     };
   } else {
     constraints = {width: {exact: e.target.value}};
   }
   clearErrorMessage();
   console.log('applying ' + JSON.stringify(constraints));
   track.applyConstraints(constraints)
       .then(() => {
         console.log('applyConstraint success');
         displayVideoDimensions('applyConstraints');
       })
       .catch(err => {
         errorMessage('applyConstraints', err.name);
       });
 }
 
 widthInput.onchange = constraintChange;
 
 sizeLock.onchange = () => {
   if (sizeLock.checked) {
     console.log('Setting fixed size');
     video.style.width = '100%';
   } else {
     console.log('Setting auto size');
     video.style.width = 'auto';
   }
 };
 
 function getMedia(constraints) {
   if (stream) {
     stream.getTracks().forEach(track => {
       track.stop();
     });
   }
 
   clearErrorMessage();
   videoblock.style.display = 'none';
   navigator.mediaDevices.getUserMedia(constraints)
       .then(gotStream)
       .catch(e => {
         errorMessage('getUserMedia', e.message, e.name);
       });
 } */